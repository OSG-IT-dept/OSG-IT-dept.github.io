<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Servo → Knee Multi-Link (Rigid, Off-Center Hip Anchors)</title>
<style>
  :root{--bg:#0f1220;--panel:#171b2e;--ink:#e8ecff;--muted:#aab1d9;--accent:#6eb2ff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:360px 1fr;height:100%}
  .panel{background:var(--panel);padding:14px 16px;border-right:1px solid #2b3153;overflow:auto}
  .panel h2{margin:8px 0 6px;font-size:16px}
  .row{display:flex;gap:10px;align-items:center;margin:6px 0}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  label{display:flex;gap:6px;align-items:center}
  input[type=number]{width:90px}
  input[type=range]{width:100%}
  .hr{height:1px;background:#2b3153;margin:10px 0}
  .pill{background:#273158;color:#fff;padding:2px 8px;border-radius:999px;font-size:12px}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  button{background:#28335d;color:#fff;border:1px solid #3a4470;border-radius:6px;padding:6px 10px;cursor:pointer}
  button:hover{background:#324075}
  canvas{background:#0b0e1a;width:100%;height:100%;display:block}
  .small{font-size:12px;color:var(--muted)}
  .key{display:flex;gap:10px;align-items:center;margin-top:6px}
  .swatch{width:14px;height:3px;border-radius:2px;background:#c2cffc}
  .swatch.dash{background:linear-gradient(90deg, rgba(255,120,120,0.95) 50%, transparent 50%); background-size:8px 2px}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h2>Servo input</h2>
    <div class="row"><label>Servo angle <span id="servoDegLbl" class="pill mono">60.0°</span></label></div>
    <input id="servoDeg" type="range" min="0" max="180" step="0.1" value="60"/>

    <div class="hr"></div>
    <h2>Fixed link lengths</h2>
    <div class="grid">
      <label>L1 horn (m) <input id="L1" type="number" step="0.001" value="0.012"></label>
      <span></span>
      <label>L2 rod (m)  <input id="L2" type="number" step="0.001" value="0.085"></label>
      <label>L4 tendon (m) <input id="L4" type="number" step="0.001" value="0.030"></label>
    </div>

    <div class="hr"></div>
    <h2>L3 (hip link) off-center anchors</h2>
    <div class="small">Anchors A (to L2) and B (to L4) measured from L3 hip pivot in the link’s local frame.</div>
    <div class="grid">
      <label>rA (m) <input id="L3_rA" type="number" step="0.001" value="0.030"></label>
      <label>αA (deg) <input id="L3_aA" type="number" step="0.1" value="0"></label>
      <label>rB (m) <input id="L3_rB" type="number" step="0.001" value="0.030"></label>
      <label>αB (deg) <input id="L3_aB" type="number" step="0.1" value="180"></label>
    </div>

    <div class="hr"></div>
    <h2>Results</h2>
    <div class="row"><span>Knee angle</span><span id="kneeOut" class="mono">–</span></div>
    <div class="row"><span>dθ<sub>knee</sub>/dθ<sub>servo</sub></span><span id="ratioOut" class="mono">–</span></div>
    <div class="row"><span>Status</span><span id="reachOut" class="mono">–</span></div>

    <div class="hr"></div>
    <h2>Drag locks</h2>
    <div class="row"><label><input id="lockServo" type="checkbox"> Lock Servo Base</label></div>
    <div class="row"><label><input id="lockHip" type="checkbox"> Lock Hip Pivot</label></div>
    <div class="row"><label><input id="lockKnee" type="checkbox"> Lock Knee Pivot</label></div>

    <div class="hr"></div>
    <h2>Save / Load</h2>
    <div class="row">
      <button id="saveBtn">Copy JSON</button>
      <button id="loadBtn">Load JSON</button>
    </div>
    <textarea id="cfgBox" class="mono" rows="6" style="width:100%;background:#0b0e1a;color:#dfe6ff;border:1px solid #2b3153;border-radius:6px;padding:6px;"></textarea>

    <div class="hr"></div>
    <div class="small">
      <b>Drag points in canvas:</b> Servo Base, Hip Pivot (L3), Knee Pivot.  
      Links are always rigid and drawn **dot-to-dot**. If a pose is unreachable, the last valid pose is displayed and the attempted pose is shown faintly.
      <div class="key">
        <span class="swatch"></span><span>solid = rigid closed links</span>
      </div>
      <div class="key">
        <span class="swatch dash"></span><span>dashed red = capped placeholders (no stretching)</span>
      </div>
    </div>
  </div>

  <canvas id="cv"></canvas>
</div>

<script>
/* ========= math helpers ========= */
const TAU=Math.PI*2, d2r=d=>d*Math.PI/180, r2d=r=>r*180/Math.PI;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function dist2(a,b){const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy;}
function hypot2(dx,dy){return Math.hypot(dx,dy);}

/* ========= state ========= */
const st={
  m2px:220,
  servo:{x:-0.10,y:0.00},   // ground servo pivot
  hip:{x:0.00,y:0.05},      // ground hip pivot (L3)
  knee:{x:0.10,y:0.00},     // ground knee pivot
  servoDeg:60,
  L1:0.012, L2:0.085, L4:0.030,
  L3:{rA:0.030,aA:0, rB:0.030,aB:180},
  drag:null,
  // cache last reachable pose so we never displace anchors in unreachable attempts
  lastReach:{ valid:false, servoDeg:null, horn:{x:0,y:0}, A:{x:0,y:0}, B:{x:0,y:0}, phi:0, kneeAng:0 }
};

/* ========= DOM ========= */
const elServo=document.getElementById('servoDeg');
const elServoLbl=document.getElementById('servoDegLbl');
const elL1=document.getElementById('L1');
const elL2=document.getElementById('L2');
const elL4=document.getElementById('L4');
const el_rA=document.getElementById('L3_rA'), el_aA=document.getElementById('L3_aA');
const el_rB=document.getElementById('L3_rB'), el_aB=document.getElementById('L3_aB');
const kneeOut=document.getElementById('kneeOut');
const ratioOut=document.getElementById('ratioOut');
const reachOut=document.getElementById('reachOut');
const cfgBox=document.getElementById('cfgBox');
const lockServo=document.getElementById('lockServo');
const lockHip=document.getElementById('lockHip');
const lockKnee=document.getElementById('lockKnee');

/* ========= canvas ========= */
const cv=document.getElementById('cv'); const g=cv.getContext('2d');
function fit(){cv.width=cv.clientWidth*devicePixelRatio;cv.height=cv.clientHeight*devicePixelRatio;
  g.setTransform(st.m2px*devicePixelRatio,0,0,-st.m2px*devicePixelRatio,cv.width/2,cv.height/2);}
window.addEventListener('resize',()=>{fit();draw();}); fit();

/* ========= input binding ========= */
function readUI(geometryChanged=true){
  st.servoDeg=parseFloat(elServo.value);
  st.L1=parseFloat(elL1.value)||0.012;
  st.L2=parseFloat(elL2.value)||0.085;
  st.L4=parseFloat(elL4.value)||0.030;
  st.L3.rA=parseFloat(el_rA.value)||0.03;  st.L3.aA=parseFloat(el_aA.value)||0;
  st.L3.rB=parseFloat(el_rB.value)||0.03;  st.L3.aB=parseFloat(el_aB.value)||180;
  elServoLbl.textContent=`${(+st.servoDeg).toFixed(1)}°`;
  if (geometryChanged) st.lastReach.valid = false; // reset cache when geometry changes
  draw();
}
[elL1,elL2,elL4,el_rA,el_aA,el_rB,el_aB].forEach(e=>e.addEventListener('input',()=>readUI(true)));
elServo.addEventListener('input',()=>readUI(false));

/* ========= transforms ========= */
function rot(vx,vy,phi){const c=Math.cos(phi), s=Math.sin(phi);return {x:c*vx - s*vy, y:s*vx + c*vy};}
function localToWorld(pivot, r, alphaDeg, phi){
  const a=d2r(alphaDeg);
  const vx=r*Math.cos(a), vy=r*Math.sin(a);
  const w=rot(vx,vy,phi);
  return {x:pivot.x + w.x, y:pivot.y + w.y};
}

/* ========= solver =========
   Solve for hip orientation φ so BOTH constraints are satisfied:
     |A(φ) - horn| = L2   AND   |B(φ) - knee| = L4
   This is over one variable, two constraints; not all geometries will close.
   Strategy:
   - Minimize H(φ)=F^2+G^2 with coarse scan + local golden search.
   - Accept ONLY if |F| and |G| < epsRigid.
   - Else, keep last valid pose (no link stretching, no anchor displacement).
*/
function solvePhi(horn,knee, epsRigid=1e-5){
  const {rA,aA,rB,aB}=st.L3;
  let bestPhi=0, bestH=Infinity;
  // coarse scan (dense to avoid missing narrow solutions)
  for(let d=0; d<360; d+=0.1){
    const phi=d2r(d);
    const A=localToWorld(st.hip,rA,aA,phi), B=localToWorld(st.hip,rB,aB,phi);
    const F = Math.hypot(A.x-horn.x, A.y-horn.y) - st.L2;
    const G = Math.hypot(B.x-knee.x, B.y-knee.y) - st.L4;
    const H = F*F + G*G;
    if(H < bestH){ bestH=H; bestPhi=phi; }
  }
  // refine with golden-section around best
  let lo=bestPhi - d2r(5), hi=bestPhi + d2r(5);
  function evalAt(phi){
    const A=localToWorld(st.hip,rA,aA,phi), B=localToWorld(st.hip,rB,aB,phi);
    const F = Math.hypot(A.x-horn.x, A.y-horn.y) - st.L2;
    const G = Math.hypot(B.x-knee.x, B.y-knee.y) - st.L4;
    return {H:F*F+G*G, F, G, A, B};
  }
  for(let k=0;k<64;k++){
    const m1 = lo + (hi-lo)/3, m2 = hi - (hi-lo)/3;
    if (evalAt(m1).H < evalAt(m2).H) hi = m2; else lo = m1;
  }
  const mid=(lo+hi)/2;
  const {H,F,G,A,B}=evalAt(mid);
  const exact = (Math.abs(F) < epsRigid) && (Math.abs(G) < epsRigid);
  return {phi:mid, A, B, exact, H};
}

/* compute current attempt AND choose what to draw (current or lastReach) */
function compute(servoDeg){
  // horn from servo
  const th=d2r(servoDeg);
  const hornAttempt={x: st.servo.x + st.L1*Math.cos(th), y: st.servo.y + st.L1*Math.sin(th)};
  // solve φ
  const sol=solvePhi(hornAttempt, st.knee);
  const phiAttempt=sol.phi;
  const Aattempt=sol.A, Battempt=sol.B;
  const kneeAngAttempt = Math.atan2(st.knee.y - Battempt.y, st.knee.x - Battempt.x);

  if (sol.exact){
    st.lastReach = {
      valid:true,
      servoDeg: servoDeg,
      horn: hornAttempt,
      A: Aattempt,
      B: Battempt,
      phi: phiAttempt,
      kneeAng: kneeAngAttempt
    };
  }

  // Choose draw pose: exact current if reachable, otherwise last valid (if any)
  const use = sol.exact && st.lastReach.valid ? st.lastReach : (st.lastReach.valid ? st.lastReach : {
    valid:false, horn:hornAttempt, A:AAttempt, B:BAttempt, phi:phiAttempt, kneeAng:kneeAngAttempt
  });

  return {
    reachable: sol.exact,
    frozen: !sol.exact && st.lastReach.valid,
    // draw pose (rigid, dot-to-dot)
    drawHorn: use.horn, drawA: use.A, drawB: use.B, drawPhi: use.phi, drawKneeAng: use.kneeAng,
    // attempt pose (for faint overlays)
    attempt: { horn: hornAttempt, A: Aattempt, B: Battempt, phi: phiAttempt, kneeAng: kneeAngAttempt, H: sol.H }
  };
}

/* ========= drawing ========= */
function draw(){
  g.clearRect(-cv.width, -cv.height, cv.width*2, cv.height*2);

  // grid
  g.save(); g.lineWidth=1/st.m2px; g.strokeStyle='rgba(180,200,255,0.08)';
  for(let x=-2;x<=2;x+=0.05){g.beginPath();g.moveTo(x,-2);g.lineTo(x,2);g.stroke();}
  for(let y=-2;y<=2;y+=0.05){g.beginPath();g.moveTo(-2,y);g.lineTo(2,y);g.stroke();}
  g.restore();

  const mW=3/st.m2px;
  const M=compute(st.servoDeg);

  // ground pivots
  dot(st.servo,'#6eb2ff',7); label(st.servo,'Servo');
  dot(st.hip,'#f6a972',7);   label(st.hip,'Hip (L3 pivot)');
  dot(st.knee,'#f0e06a',7);  label(st.knee,'Knee pivot');

  // L1: servo horn (solid)
  g.strokeStyle='#6eb2ff'; g.lineWidth=mW;
  g.beginPath(); g.moveTo(st.servo.x,st.servo.y); g.lineTo(M.drawHorn.x,M.drawHorn.y); g.stroke();
  dot(M.drawHorn,'#66e3a0',5); label(M.drawHorn,'L1 tip');

  // L2 & L4 rigid links (always dot-to-dot for the DRAW pose)
  if (M.reachable){
    g.strokeStyle='#c2cffc';
    g.beginPath(); g.moveTo(M.drawHorn.x,M.drawHorn.y); g.lineTo(M.drawA.x,M.drawA.y); g.stroke(); // L2
    g.beginPath(); g.moveTo(M.drawB.x,M.drawB.y); g.lineTo(st.knee.x,st.knee.y); g.stroke();       // L4
  } else {
    // frozen pose: draw capped dashed rods toward correct length from draw pose
    // (purely visual hint; draw remains rigid at the cached pose)
    g.save(); g.lineWidth=mW; g.setLineDash([6/st.m2px,4/st.m2px]); g.strokeStyle='rgba(255,120,120,0.95)';
    // L2 dashed from drawHorn toward drawA (capped to L2)
    let vHAx = M.drawA.x - M.drawHorn.x, vHAy = M.drawA.y - M.drawHorn.y;
    let dHA = Math.hypot(vHAx, vHAy) || 1e-9;
    let L2end = { x: M.drawHorn.x + (vHAx/dHA)*st.L2, y: M.drawHorn.y + (vHAy/dHA)*st.L2 };
    g.beginPath(); g.moveTo(M.drawHorn.x,M.drawHorn.y); g.lineTo(L2end.x,L2end.y); g.stroke();

    // L4 dashed from knee backward toward drawB (capped to L4)
    let vBKx = st.knee.x - M.drawB.x, vBKy = st.knee.y - M.drawB.y;
    let dBK = Math.hypot(vBKx, vBKy) || 1e-9;
    let L4start = { x: st.knee.x - (vBKx/dBK)*st.L4, y: st.knee.y - (vBKy/dBK)*st.L4 };
    g.beginPath(); g.moveTo(L4start.x,L4start.y); g.lineTo(st.knee.x,st.knee.y); g.stroke();
    g.restore();

    // faint attempt overlay (does NOT move anchors)
    g.save(); g.lineWidth = (1.25)/st.m2px; g.setLineDash([4/st.m2px,4/st.m2px]); g.strokeStyle = 'rgba(200,220,255,0.25)';
    g.beginPath(); g.moveTo(M.attempt.horn.x,M.attempt.horn.y); g.lineTo(M.attempt.A.x,M.attempt.A.y); g.stroke();
    g.beginPath(); g.moveTo(M.attempt.B.x,M.attempt.B.y); g.lineTo(st.knee.x,st.knee.y); g.stroke();
    g.restore();
  }

  // L3 body (hip → A and hip → B), always drawn for the DRAW pose
  g.strokeStyle='#ffb28a';
  g.beginPath(); g.moveTo(st.hip.x,st.hip.y); g.lineTo(M.drawA.x,M.drawA.y); g.stroke();
  g.beginPath(); g.moveTo(st.hip.x,st.hip.y); g.lineTo(M.drawB.x,M.drawB.y); g.stroke();
  dot(M.drawA,'#ffb28a',4); label(M.drawA,'A');
  dot(M.drawB,'#ffb28a',4); label(M.drawB,'B');

  // outputs
  const kneeDeg=r2d(M.drawKneeAng);
  kneeOut.textContent = isFinite(kneeDeg)? `${kneeDeg.toFixed(2)}°` : 'NaN';
  // instantaneous ratio via small perturbation (uses DRAW pose mapping)
  const eps=0.05, M2=compute(clamp(st.servoDeg+eps,0,180));
  const ratio=(r2d(M2.drawKneeAng)-r2d(M.drawKneeAng))/eps;
  ratioOut.textContent = isFinite(ratio)? ratio.toFixed(3) : 'NaN';

  reachOut.textContent = M.reachable
    ? 'Reachable (rigid closure)'
    : (M.frozen ? 'Unreachable — showing last reachable pose (no link stretching)' : 'Unreachable — (no prior reachable pose)');
}

/* ========= tiny draw utils ========= */
function dot(p,color,px){const r=px/st.m2px; g.save(); g.fillStyle=color; g.beginPath(); g.arc(p.x,p.y,r,0,TAU); g.fill(); g.restore();}
function label(p,text){
  g.save(); g.setTransform(1,0,0,1,0,0);
  const sx=p.x*st.m2px + cv.width/2, sy = -p.y*st.m2px + cv.height/2;
  g.fillStyle='#9fb3ff'; g.font='12px ui-monospace,monospace'; g.fillText(text, sx+8, sy-8); g.restore();
}

/* ========= drag handling ========= */
function s2w(x,y){const r=cv.getBoundingClientRect(), X=(x-r.left)*devicePixelRatio, Y=(y-r.top)*devicePixelRatio;
  return {x:(X-cv.width/2)/(st.m2px*devicePixelRatio), y:-(Y-cv.height/2)/(st.m2px*devicePixelRatio)};}
function hit(p,m){const r=12/st.m2px; return Math.abs(p.x-m.x)<r && Math.abs(p.y-m.y)<r;}
cv.addEventListener('mousedown',e=>{
  const m=s2w(e.clientX,e.clientY);
  if(hit(st.servo,m) && !lockServo.checked) st.drag='servo';
  else if(hit(st.hip,m) && !lockHip.checked) st.drag='hip';
  else if(hit(st.knee,m) && !lockKnee.checked) st.drag='knee';
});
window.addEventListener('mousemove',e=>{
  if(!st.drag) return;
  const m=s2w(e.clientX,e.clientY);
  st[st.drag]=m;
  // geometry changed if moving any ground pivot — reset cache
  st.lastReach.valid=false;
  draw();
});
window.addEventListener('mouseup',()=>st.drag=null);

/* ========= save/load ========= */
document.getElementById('saveBtn').addEventListener('click', ()=>{
  const cfg={servo:st.servo, hip:st.hip, knee:st.knee, servoDeg:st.servoDeg,
             L1:st.L1, L2:st.L2, L4:st.L4, L3:st.L3};
  cfgBox.value=JSON.stringify(cfg,null,2); cfgBox.select(); document.execCommand('copy');
});
document.getElementById('loadBtn').addEventListener('click', ()=>{
  try{
    const c=JSON.parse(cfgBox.value);
    if(c.servo) st.servo=c.servo; if(c.hip) st.hip=c.hip; if(c.knee) st.knee=c.knee;
    if(c.servoDeg!=null){st.servoDeg=c.servoDeg; elServo.value=c.servoDeg;}
    if(c.L1!=null){st.L1=c.L1; elL1.value=c.L1}
    if(c.L2!=null){st.L2=c.L2; elL2.value=c.L2}
    if(c.L4!=null){st.L4=c.L4; elL4.value=c.L4}
    if(c.L3){st.L3=c.L3; el_rA.value=c.L3.rA; el_aA.value=c.L3.aA; el_rB.value=c.L3.rB; el_aB.value=c.L3.aB;}
    // geometry changed
    st.lastReach.valid=false;
    readUI(false);
  }catch(e){alert('Invalid JSON');}
});

/* ========= init ========= */
readUI(true); draw();
</script>
</body>
</html>