<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Marine Photo Report Composer v6</title>
<style>
  body {font-family: system-ui, sans-serif; background:#0b1020; color:#e8eeff; margin:0; padding:0;}
  .container {max-width:900px; margin:20px auto; background:#121832; padding:20px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.4);}
  h1 {color:#7aa2ff;}
  canvas {border:1px solid #2a366f; border-radius:6px; width:100%; background:#0d1430;}
  .tools {display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
  button, input, textarea {padding:8px; border-radius:8px; border:1px solid #2a366f; background:#0d1430; color:#e8eeff; cursor:pointer;}
  button.active {background:#7aa2ff; color:#0b1020; font-weight:bold;}
  textarea {width:100%; min-height:50px;}
  .photo-block {margin-top:20px;}
  .muted {color:#9fb0d0; font-size:13px;}
</style>
</head>
<body>
<div class="container">
  <h1>Marine Photo Report Composer</h1>
  <p class="muted">Capture or upload up to 5 annotated photos, add notes, and save a Teams-compatible PDF directly to your device.</p>

  <div>
    <label>Job Title</label>
    <input id="jobTitle" placeholder="e.g., MV OCEAN SPIRIT - Hold Inspection">
  </div>
  <br>
  <input type="file" id="photoInput" accept="image/*" capture="environment" multiple>

  <div id="photoList"></div>

  <hr style="margin:20px 0;border-color:#26305e;">
  <button id="savePDF">ðŸ’¾ Save PDF to Device (Teams Compatible)</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
const MAX_PHOTOS = 5;
const photoInput = document.getElementById('photoInput');
const photoList = document.getElementById('photoList');
const { jsPDF } = window.jspdf;
const images = [];

photoInput.addEventListener('change', e => {
  const files = Array.from(e.target.files).slice(0, MAX_PHOTOS);
  photoList.innerHTML = '';
  images.length = 0;
  files.forEach((file, i) => createEditor(file, i + 1));
});

function getCanvasCoords(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
}

function createEditor(file, index) {
  const reader = new FileReader();
  reader.onload = () => {
    const div = document.createElement('div');
    div.className = 'photo-block';
    div.innerHTML = `
      <h3>Photo ${index}</h3>
      <div class="tools">
        <button data-tool="arrow">Arrow</button>
        <button data-tool="circle">Circle</button>
        <button data-tool="highlight">Highlight</button>
        <button data-tool="undo">Undo</button>
        <button data-tool="clear">Clear</button>
      </div>
      <canvas></canvas>
      <label>Comment / Observation</label>
      <textarea placeholder="Add a short note about this photo..."></textarea>
    `;
    photoList.appendChild(div);

    const canvas = div.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      images[index-1] = { canvas, note: div.querySelector('textarea') };
    };
    img.src = reader.result;

    let drawing = false, tool = null, startX, startY;
    const tools = div.querySelectorAll('button');
    let history = [];

    tools.forEach(btn => {
      btn.onclick = () => {
        if (btn.dataset.tool === 'undo') undo();
        else if (btn.dataset.tool === 'clear') clearCanvas();
        else { tool = btn.dataset.tool; tools.forEach(b => b.classList.remove('active')); btn.classList.add('active'); }
      };
    });

    const getXY = e => getCanvasCoords(canvas, e.clientX, e.clientY);

    canvas.addEventListener('mousedown', e => { drawing = true; const p = getXY(e); startX=p.x; startY=p.y; });
    canvas.addEventListener('mouseup', e => endDraw(e));
    canvas.addEventListener('mousemove', e => draw(e));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); drawing=true; const p=getXY(e.touches[0]); startX=p.x; startY=p.y; });
    canvas.addEventListener('touchend', e => { e.preventDefault(); endDraw(e.changedTouches[0]); });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); draw(e.touches[0]); });

    function draw(e) {
      if (!drawing || tool!=='highlight') return;
      const {x, y} = getCanvasCoords(canvas, e.clientX, e.clientY);
      ctx.strokeStyle = 'rgba(255,255,0,0.6)';
      ctx.lineWidth = 25;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(x, y);
      ctx.stroke();
      startX = x; startY = y;
    }

    function endDraw(e) {
      if (!drawing) return;
      drawing = false;
      const {x, y} = getCanvasCoords(canvas, e.clientX, e.clientY);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      history.push(imageData);
      if (tool === 'arrow' || tool === 'circle') drawShape(x, y);
    }

    function drawShape(x, y) {
      ctx.strokeStyle = tool === 'arrow' ? 'red' : 'yellow';
      ctx.lineWidth = 5;
      ctx.beginPath();
      if (tool === 'arrow') {
        const dx = x - startX, dy = y - startY;
        const angle = Math.atan2(dy, dx);
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.moveTo(x, y);
        ctx.lineTo(x - 15 * Math.cos(angle - Math.PI / 6), y - 15 * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x, y);
        ctx.lineTo(x - 15 * Math.cos(angle + Math.PI / 6), y - 15 * Math.sin(angle + Math.PI / 6));
      } else if (tool === 'circle') {
        const r = Math.hypot(x - startX, y - startY);
        ctx.arc(startX, startY, r, 0, 2 * Math.PI);
      }
      ctx.stroke();
    }

    function undo() {
      if (history.length > 0) ctx.putImageData(history.pop(), 0, 0);
    }

    function clearCanvas() {
      ctx.drawImage(img, 0, 0);
      history = [];
    }
  };
  reader.readAsDataURL(file);
}

document.getElementById('savePDF').onclick = async () => {
  if (images.length === 0) return alert("Please add photos first.");
  const doc = new jsPDF({orientation: 'portrait', unit: 'mm', format: 'a4'});
  const title = document.getElementById('jobTitle').value || 'Marine Photo Report';
  const now = new Date().toLocaleString();
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 10;
  const maxImgWidth = pageWidth - margin * 2;
  const maxImgHeight = 120;

  images.forEach((entry, i) => {
    if (i > 0) doc.addPage();
    const imgData = entry.canvas.toDataURL('image/jpeg', 0.9);
    doc.setFontSize(14);
    doc.text(title, margin, 15);
    doc.setFontSize(10);
    doc.text(`Date: ${now}`, margin, 22);
    doc.addImage(imgData, 'JPEG', margin, 30, maxImgWidth, maxImgHeight);
    const note = entry.note.value.trim();
    if (note) {
      doc.setFontSize(11);
      doc.text(`Note: ${note}`, margin, 160, {maxWidth: maxImgWidth});
    }
  });

  const pdfBlob = doc.output('blob', { type: 'application/pdf' });

  if ('showSaveFilePicker' in window) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: `${title.replace(/\s+/g,'_')}_Report.pdf`,
        types: [{ description: 'PDF File', accept: { 'application/pdf': ['.pdf'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(pdfBlob);
      await writable.close();
      alert('âœ… PDF saved successfully to device. You can now share it via Teams.');
    } catch (err) {
      console.warn(err);
      alert('Save canceled or failed.');
    }
  } else {
    // fallback for iOS or unsupported browsers
    const a = document.createElement('a');
    a.href = URL.createObjectURL(pdfBlob);
    a.download = `${title.replace(/\s+/g,'_')}_Report.pdf`;
    a.click();
    URL.revokeObjectURL(a.href);
    alert('PDF downloaded (fallback mode).');
  }
};
</script>
</body>
</html>